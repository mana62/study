# インターフェイス
- 「約束ごと」や「ルールブック」みたいなもの
- クラスが「必ず実装すべきメソッドの型（名前・引数）」を定義する仕組み
- 実際の処理は書かない（中身は空）
- クラス定義時に `implements インターフェイス名` で使う
- インターフェイスを使うと、複数のクラスに共通の振る舞いを強制できる

---

## 基本構文

```bash
# インターフェイスの定義
# しゃべる機能を持つクラスたち
interface Talkable {
    public function talk();
}
→ このインターフェイスは「talk() っていうメソッドを持っててね」っていう約束

---

# 犬クラス
class Dog implements Talkable {
    public function talk() {
        return "ワン！";
    }
}


# ロボットクラス
class Robot implements Talkable {
    public function talk() {
        return "ピピピ！";
    }
}

# 使う時
function makeItTalk(Talkable $thing) {
    echo $thing->talk();
}

makeItTalk(new Dog());    # ワン！
makeItTalk(new Robot());  # ピピピ！

```
---

## どんな時に使うのか

| シーン | 使いどころ |
|--------|------------|
| 複数のクラスに同じメソッドを持たせたい | 共通のルールを強制できる |
| 処理の中身はクラスごとに変えたい | インターフェイスで型だけ決めて、実装は自由に |
| 交換可能なクラスを作りたい | インターフェイスを使えば、どのクラスでも同じように扱える |

---

## 注意点

- インターフェイスには**処理を書けない**（中身は空）
- クラスは**すべてのメソッドを実装しないとエラーになる**
- プロパティ（変数）は定義できない
- 複数のインターフェイスを**同時に実装することも可能**

```php
interface A {
    public function foo();
}

interface B {
    public function bar();
}

class MyClass implements A, B {
    public function foo() { /* ... */ }
    public function bar() { /* ... */ }
}
