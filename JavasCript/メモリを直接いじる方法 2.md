# メモリを直接いじる方法
＝JSが用意した安全な箱の中でバイナリを扱うことができる
＝JavaScriptで「数字のバイト列」を扱う

普段のJavaScriptはこういう世界
```js
let name = "田中";
let age = 20;
```

でもコンピュータの中身
```js
010101010101010...

// 0と1の並び（バイナリ）
```

## 🟣 バイナリデータとは？
＝メモリ（物理領域）上に保管された**0と1の生のバイトデータ**

## 🟣 1バイトは？
＝8ビットで構成されてる

## 🟣 バイナリを直接扱いたい場面とは？
| 使う場面          | 理由           |
| ------------- | ------------ |
| 画像処理          | ピクセルはバイトの集合  |
| 音声処理          | 波形データは数値配列   |
| ファイル読み書き      | PDFやZIPはバイナリ |
| ネットワーク通信      | TCP/UDPはバイト列 |
| WebAssembly連携 | メモリ共有が必要     |
＝これらの時に必要になるのが、`ArrayBuffer / TypedArray / DataView`

## 🟣 ArrayBufferとは？
＝**「ただのメモリ領域」**
＝「バイトを入れる箱」

```js
const buffer = new ArrayBuffer(16);
```
16バイト
つまり128ビット
の空っぽの領域を確保する
**ArrayBuffer単体では中身を見たり書いたりできない**

## 🟣 TypedArrayとは？
＝ArrayBufferを **「数値の配列として見る」道具**

```js
// 例：8ビットずつ見る
const buffer = new ArrayBuffer(4);
const arr = new Uint8Array(buffer);

arr[0] = 255;
arr[1] = 10;

console.log(arr);
// Uint8Array(4) [255, 10, 0, 0]
```
これはつまりメモリをこう見てる：
```js
[1バイト][1バイト][1バイト][1バイト]
```
16ビットずつ見る
```js
const arr16 = new Uint16Array(buffer);
console.log(arr16);
```
するとこうなる：
```js
[2バイト][2バイト]
```
同じメモリを違う区切り方で見てるだけ

## 🟣 DataViewとは？
＝TypedArrayより**細かく見る道具**
16ビットで読む
32ビットで読む
エンディアン指定する

```js
// 例：16ビット整数を書き込む
const buffer = new ArrayBuffer(2);
const view = new DataView(buffer);

view.setUint16(0, 256);
```

## エンディアンとは？
数字256は2バイト必要
```js
256 = 00000001 00000000
```
これをメモリに入れるとき順番が2種類ある

### ビッグエンディアン（人間が自然）
```js
[00000001][00000000]
```

### リトルエンディアン（CPUがよく使う）
```js
[00000000][00000001]
```
順番が逆

DataViewでは指定できる
```js
view.setUint16(0, 256, true); // true → リトルエンディアン
view.setUint16(0, 256, false); // false → ビッグエンディアン
```

## まとめ
①JavaScriptでもメモリっぽい操作はできる
②ただし安全に制限されている
③ArrayBufferで領域を確保して
④TypedArrayで配列として扱う
⑤DataViewならエンディアンも指定できる
⑥主にバイナリ処理で使う