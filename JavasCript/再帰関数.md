# 再帰関数
「関数の中で自分自身を呼び出す関数」＝ 再帰関数（recursive function）
**再帰は“深さがわからない入れ子構造”を処理するための道具**

## 再帰関数は 必ずこの形
```js
function f(n) {
  if (終了条件) {
    return 終了時の値;
  }

  return 現在の処理 + f(n - 1);
}

```

```js
function countdown(n) {
  console.log(n);
  if (n > 1) {
    countdown(n - 1); // ← 自分自身を呼んでる
  }
}
countdown(5);
```

結果
```js
5
4
3
2
1
```

## 再帰関数の構造はいつも 2 つだけ
### ① ベースケース（終わりの条件）
✅ これがないと永遠に呼び続けて無限ループになる

```js
if (n === 0) return;
```

### ② 再帰呼び出し（自分自身を呼ぶ）
✅ 問題を少し小さくして呼ぶ

```js
return f(n - 1);
```

## どんな時に使うのか
### 1. 入れ子（ネスト）構造を処理したい時（ツリー構造・階層構造 → 再帰が最強）

```bash
# 例：フォルダの中にフォルダがあって、その中にまたフォルダがある
root
 ├─ A
 │   ├─ A1
 │   └─ A2
 └─ B
     └─ B1
```

→ 階層構造は、ループで書くと地獄だが、再帰ならめちゃくちゃ自然

```js
function walk(folder) {
  console.log(folder.name);
  for (const child of folder.children) {
    walk(child); // ← 再帰
  }
}
```

### 2. 同じ処理を“問題を小さくしながら”繰り返したい時

```js
// 例：カウントダウン
function countdown(n) {
  console.log(n);
  if (n > 1) countdown(n - 1);
}
```

→ 「n を 1 ずつ減らしながら同じ処理を繰り返す」= 再帰が自然


| ケース | 再帰が向いてる理由 |
|--------|----------------------|
| **ツリー・階層構造** | 深さが不定なのでループが書きづらい |
| **問題を小さくしていく処理** | 再帰の構造と相性が良い |
| **数学的な再帰定義** | コードがそのまま定義になる |
| **探索（迷路・木構造）** | 分岐しながら進む処理が自然 |

逆に「普通の繰り返し」には向かない