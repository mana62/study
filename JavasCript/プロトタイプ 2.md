# プロトタイプ
＝JavaScript のオブジェクトが持つ **親オブジェクトへの参照**

# プロトタイプチェーン
＝親 → その親 → さらに親… とたどって機能を探す仕組み（どんなオブジェクトも必ず親を持つ）

## オブジェクト
**プロトタイプを持つのは「オブジェクト（object）」だけ**
ただし、JavaScript では **ほぼ全部がオブジェクト扱い** なので、結果的にほとんどのものがプロトタイプを持つ

### ✔️プロトタイプを持つもの
JavaScript では次のものは全部 オブジェクトとして扱われるので、プロトタイプを持つ
- 配列（Array）
- 関数（Function）
- 日付（Date）
- 正規表現（RegExp）
- Promise
- クラスのインスタンス
- 文字列・数値・真偽値の ラッパーオブジェクト

＝つまり、こういうの全部プロトタイプチェーンを持つ

```js
[].__proto__ === Array.prototype
(() => {}).__proto__ === Function.prototype
"abc".__proto__ === String.prototype
```

### ❌プロトタイプを持たないもの
プリミティブ値（単純な値）はプロトタイプを持たない
- number（例: 123）
- string（例: "abc"）
- boolean（true / false）
- null
- undefined
- symbol
- bigint

### string や number がメソッドを使える理由（ややこしいところ・・・）
- プリミティブ値は本来プロトタイプを持たないのに、下記のように書ける

```js
"abc".toUpperCase()
```
これは JavaScript が内部でこうしているから：
```js
// コード
"abc" → String オブジェクトに一時変換 → String.prototype を参照 → すぐ破棄
```
つまり：
プリミティブ → プロトタイプなし
でも JS が勝手に**一時的にオブジェクト化**してくれる

## 例
```js
const parent = { greet() { console.log("hi"); } };
const child = Object.create(parent);

child.greet(); // ← child にないのに呼べる
```

内部 :
```js
// プロトタイプチェーン
child → parent → Object.prototype → null
```

## Object.create()
＝**「このオブジェクトの親はこれにしたい」**と明示的に指定したいときに使う
```js
const parent = { greet() { console.log("hi"); } };
const child = Object.create(parent);

child.greet(); // parent を参照している
```
- 「親を自分で決める」ための方法
- `Object.create()` を使うと **親を自分で指定できる**
- 使わなくても、JS が自動で親を設定してくれる

⚠️ でも、普通のオブジェクトも最初から親を持っている
### オブジェクト
```js
// 例１
const obj = {};
```
↓
```js
obj → Object.prototype → null
```
＝何もしてなくても親を参照している

### 配列
```js
const arr = [1,2,3];
```
↓
```js
arr → Array.prototype → Object.prototype → null
```
＝だから arr.map() が使える

```bash
arr
  ↑
Array.prototype   ← map(), filter(), reduce() などが入ってる
  ↑
Object.prototype  ← toString(), hasOwnProperty() などが入ってる
  ↑
null              ← チェーンの終点
```

**JavaScript のオブジェクトは 自分が持っていないプロパティを prototype に探しに行く**

```bash
arr.map
↓
arr に map がある？ → ない
↓
Array.prototype に map がある？ → ある！
↓
実行できる
```
＝プロトタイプチェーン＝継承の仕組み

## Object.getPrototypeOf(obj)
＝「このオブジェクトの親って誰？」を調べる関数

```js
// 例
const obj = {};
console.log(Object.getPrototypeOf(obj));
```

```js
// 結果
Object.prototype
```
- {} の親は Object.prototype
- [] の親は Array.prototype
- 関数の親は Function.prototype
などが確認できる

### 使いどころ
- デバッグ
- プロトタイプチェーンの確認
- ライブラリ内部の挙動を理解したいとき

## Object.setPrototypeOf(obj, parent)（非推奨）
＝「既存オブジェクトの親を後から変更する」

```js
// 例
const a = {};
const b = { x: 10 };

Object.setPrototypeOf(a, b);

console.log(a.x); // 10
```
＝a の親を b に変えたので、a から b のプロパティが見えるようになる

### ❌ なぜ非推奨なのか？
- ① めちゃくちゃ遅い
  - プロトタイプチェーンを途中で変えると、JavaScript エンジンの最適化が崩れてしまう
    - → 実行速度が落ちる
    - → 予測不能な動作になることもある
- ② コードが読みにくくなる
  - 普通は「オブジェクトの親は作った瞬間に決まる」という前提でコードが書かれている
  - 後から親を変えると、挙動が追いにくくなる

## プロトタイプ関連メソッドまとめ

| メソッド | 役割 |
|----------|------|
| `Object.create(parent)` | 親を指定して「新しいオブジェクトを作る」 |
| `Object.getPrototypeOf(obj)` | 既存オブジェクトの「親を調べる」 |
| `Object.setPrototypeOf(obj, parent)` | 既存オブジェクトの「親を後から変更する」※非推奨 |

## オブジェクトの作り方と prototype の決まり方

| 方法 | 親（prototype）はどう決まる？ |
|------|------------------------------|
| `{}` で作る | 自動で `Object.prototype` が親になる |
| `[]` で作る | 自動で `Array.prototype` が親になる |
| `function Foo(){}` | 自動で `Foo.prototype` が親になる |
| `new Foo()` | `Foo.prototype` が親になる |
| `Object.create(parent)` | 親を自分で指定できる |
