# 即時実行関数式（IIFE）
＝ 定義した瞬間にその場で実行される関数

```js
(function() {
  // ここがすぐ実行される
})();
```
またはアロー関数版 :

```js
(() => {
  // すぐ実行される
})();
```

✅ 関数を作って → その場で呼び出す という流れを一気にやっている

### なぜ即時関数が必要なのか
一度だけ実行したい処理を、外から触れない安全なスコープで閉じ込めたい時

### 即時関数を使う目的
#### ① プライベート変数を作りたい

```js
// 例 : 外から触れられない count を作りたい時
const counter = (() => {
  let count = 0;
  return () => ++count;
})();
```

#### ② 初期化処理を一度だけ実行したい
```js
// 例：設定読み込み、キャッシュ作成、イベント登録など
const config = (() => {
  console.log("設定読み込み中…");
  return { mode: "prod" };
})();
```

⭕️即時関数（IIFE）は：
- 定義した瞬間に実行される関数
- 一度だけ実行したい処理を閉じ込めるための仕組み
- クロージャと組み合わせるとプライベート変数が作れる
- 昔のJSではスコープを作るために必須だった

## 昔のJSは即時関数しかスコープを作る方法がなかったが、今はスコープを作る方法は 4 つある

#### ① ブロックスコープ {}（let / const）← 現代の主役
```js
{
  let x = 1;
  const y = 2;
}
console.log(x); // エラー
```
→ let と const が登場してからは、ブロック {} だけでスコープが作れるようになった
→ これが IIFE の代わりになる

#### ② 関数スコープ（function）
```js
function test() {
  let x = 1;
}
```
→ これは昔からある方法
→ IIFE はこれを その場で実行するだけ

#### ③ モジュールスコープ（ES Modules）

```js
// module.js
const x = 1;
// このファイルの中だけ
```
→ <script type="module"> や .mjs では
ファイル全体がスコープになる

#### ④ クラススコープ（class）
```js
class A {
  #secret = 123; // 外から見えない
}
```
→ クラスには独自のスコープとプライベートフィールドがある

## IIFE はもう不要なのか？
→ スコープを作るだけ”なら不要

```js
(() => {
  let x = 1;
})();
```
これは今ならこう書ける：

```js
{
  let x = 1;
}
```

#### それでも IIFE が使われる理由
① 初期化処理を一度だけ実行したい
```js
const counter = (() => {
  let count = 0;
  return () => ++count;
})();
```
→ 一度だけ実行して、内部状態を閉じ込めて、関数だけ返す
これはブロックでは代替できない

② クロージャで“プライベート変数”を作りたい
→ ブロック {} では値を返せないから、こういう構造は IIFE が自然

③ ライブラリやフレームワークの内部実装でよく使われる
外に汚染を出さず、内部状態を保持したい時に便利