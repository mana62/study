# プロミスチェーン
＝Promiseを `.then()` でつないで、処理を **流れ**として書けるようにするテクニック
＝then / catch / finally の正体
👉 それぞれ 必ず「新しい Promise を作って返している」

①.then() は「前の処理が終わったら次を実行する」という意味
②.then() は 新しい Promise を返す
③だから .then().then().then() と つなげて順番に実行できる

## Promiseチェーンの本質
- then が成功したら → 次の then に行く
- throw / reject したら → 次の catch に行く
- catch で return したら → 次の then に戻る
- finally は必ず実行される
- Promise を返したら → それが終わるまで待つ

```js
// 例
fetchData()
  .then(data => {
    console.log("1. データ取得:", data);
    return processData(data); // 次の then に渡す
  })
  .then(processed => {
    console.log("2. 整形:", processed);
    return showResult(processed);
  })
  .then(() => {
    console.log("3. 表示完了");
  })
  .catch(err => {
    console.error("エラー:", err);
  });
```
①各 .then() の return が次の .then() に渡る
②エラーは最後の .catch() でまとめて受け取れる
③処理が“階段状”に流れるので読みやすい

**then を呼ぶたびに新しい Promise が生まれている**
👉 これが 「チェーン」になる理由

## なぜプロミスチェーンが必要なのか
昔の JavaScript は「コールバック地獄」になりがち
そのためプロミスチェーンでわかりやすくした

```js
doA()
  .then(doB)
  .then(doC)
  .then(console.log);
```

## プロミスチェーンでよくある疑問
Q1. then の中で return しないとどうなる？
→ 次の then に値が渡らない
→ その then は undefined を受け取る

Q2. then の中で Promise を返すと？
→ その Promise が解決されるまで次の then は実行されない
→ これが「順番に実行できる」理由

Q3. エラーはどう流れる？
→ どこかでエラーが起きると 一番近い catch に飛ぶ

## async/awaitで書くと？
```js
async function main() {
  try {
    const data = await fetchData();
    const processed = await processData(data);
    await showResult(processed);
    console.log("完了");
  } catch (err) {
    console.error("エラー:", err);
  }
}
```

- 読みやすさ重視 → async/await
- 複雑な分岐や並列処理 → Promiseチェーン

## まとめ
- Promise は「非同期処理の結果を表す箱」
- .then() は「前の処理が終わったら次を実行」
- .then() は新しい Promise を返すのでチェーンできる
- .catch() でエラーをまとめて扱える
- async/await は Promiseチェーンをより読みやすくした書き方