# クラスの継承とコンポジション
＝クラスで親を継承する方法は2種類ある
＝結論：コンポジションの方が使われる

## 継承（extends）
**「〜は〜である（is-a関係）」**のときに使う **（A は B の一種である という関係）**

```js
// 動物クラス
class Animal {
  constructor(name) {
    this.name = name;
  }

  eat() {
    console.log(`${this.name}が食べています`);
  }
}

// 犬は動物である（is-a関係）
class Dog extends Animal { // 継承してるので親のnameが使える
  bark() {
    console.log('ワンワン!');
  }
}

const dog = new Dog('ポチ');
dog.eat();  // ポチが食べています（親から継承）
dog.bark(); // ワンワン!（自分のメソッド）
```

### is-a関係とは
**子クラスは親クラスの一種である** という継承の関係
- Dog is-a Animal
- Car is-a Vehicle
- AdminUser is-a User
＝この関係が成り立つときに **extends** を使う

### 継承のメリット
- コードの再利用が簡単
- 階層構造が明確

### 継承のデメリット
- 硬直的 : 一度決めた親子関係は変更しにくい
- 密結合 : 親の変更が子に影響する
- 多重継承できない : 1つの親からしか継承できない

## コンポジション（合成）
＝「〜を持っている（has-a関係）」のときに使う
＝必要な機能を組み合わせるアプローチ

```js
// 機能を別々に定義
const canEat = {
  eat() {
    console.log(`${this.name}が食べています`);
  }
};

const canWalk = {
  walk() {
    console.log(`${this.name}が歩いています`);
  }
};

const canSwim = {
  swim() {
    console.log(`${this.name}が泳いでいます`);
  }
};

// 必要な機能を組み合わせる
class Dog {
  constructor(name) {
    this.name = name;
    // 機能を持たせる
    Object.assign(this, canEat, canWalk); // Object.assign : コピー（マージ）
  }
}

class Fish {
  constructor(name) {
    this.name = name;
    Object.assign(this, canEat, canSwim);
  }
}

const dog = new Dog('ポチ');
dog.eat();  // ポチが食べています
dog.walk(); // ポチが歩いています

const fish = new Fish('ニモ');
fish.eat();  // ニモが食べています
fish.swim(); // ニモが泳いでいます
```

### has-a 関係とは？
＝**「A は B を持っている」**という関係のこと
＝継承（is-a）ではなく、クラスの中に別のクラスを**部品として持つ**という関係

```js
class Engine {}

class Car {
  constructor() {
    this.engine = new Engine(); // Car は Engine を持っている
  }
}
```

## クラスで使う場合はオブジェクトで使う時の違い
＝コンポジションには大きく2つのパターンがある

### パターン1: Mixin（ミックスイン）
①オブジェクトのメソッドを混ぜ込む
```js
const canEat = {
  eat() {
    console.log('食べる');
  }
};

const canWalk = {
  walk() {
    console.log('歩く');
  }
};

class Dog {
  constructor(name) {
    this.name = name;
    Object.assign(this, canEat, canWalk); // メソッドを混ぜる
    // Object.assign(this, canEat, canWalk);の呼び方
  }
}

const dog = new Dog('ポチ');
dog.eat();  // 食べる
dog.walk(); // 歩く
```

### パターン2: 委譲（Delegation）
②他のクラスのインスタンスを持つ
```js
class Engine {
  start() {
    console.log('エンジン始動');
  }
}

class Wheel {
  rotate() {
    console.log('タイヤが回る');
  }
}

class Car {
  constructor() {
    this.engine = new Engine(); // Engineを持つ（クラスの時はnewで生成）
    this.wheel = new Wheel();   // Wheelを持つ（クラスの時はnewで生成）
  }

  drive() {
    this.engine.start(); // 委譲
    this.wheel.rotate(); // 委譲
  }
}

const car = new Car();
car.drive();
// エンジン始動
// タイヤが回る
```

### 使い分け
```js
// Mixin: シンプルな機能の追加
Object.assign(this, canEat, canWalk);

// 委譲: 複雑な機能や状態を持つもの
this.engine = new Engine();
this.database = new Database();
```
- Mixin: 機能だけ借りたい（状態を持たない単純なメソッド）
- 委譲 : オブジェクトとして独立して管理したい（状態を持つ複雑なもの）

## コンポジションのメリット
- 柔軟 : 必要な機能だけを自由に組み合わせられる
- 疎結合 : 各機能が独立している
- 変更に強い : 一部の機能を変更しても他に影響しにくい

## コンポジションのデメリット
- 少し書くコードが多くなる
- 構造が複雑になることがある



## まとめ
### is-a 関係
**A は B の一種である**（継承）

| 関係 | 意味 | 例 | コード |
|------|------|------|------|
| is-a | A は B の一種 | 犬は動物である | `class Dog extends Animal` |

---

### has-a 関係
**A は B を持っている**（コンポジション）

| 関係 | 意味 | 例 | コード |
|------|------|------|------|
| has-a | A は B を持っている | 車はエンジンを持っている | `this.engine = new Engine()` |

### 継承（extends）とコンポジションの比較

| 項目 | 継承（extends） | コンポジション |
|------|------------------|----------------|
| 関係 | **is-a（〜である）** | **has-a（〜を持つ）** |
| 柔軟性 | 低い | 高い |
| 使いどころ | 明確な階層関係があるとき | 機能を組み合わせたいとき |
| モダンな推奨 | **控えめに使う** | **積極的に使う** |