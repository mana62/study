# クラス
- たくさんのオブジェクトを作りたい時に便利
- クラスは内部的には関数
- classはデフォルトでstrictモードになってる
- クラスの中で使えるのは省略可能な関数のみ（`name() {}` のような）

例：人間を100個作りたい！
```js
// classでは必ず大文字から（パスカルケース）
class Person {
  private name: string; // privateを使って外から変更させない
  private age: number; // メンバー変数
  private gender: string;

  // インストラクタ生成時の初期値
  constructor(name: string, age: number, gender: string) {
    this.name = name;
    this.age = age;
    this.gender = gender;
  }
}
⚠️private部分はタイプスクリプトの書き方！！！！

// インスタンス生成
const p1 = new Person('太郎', 20, '男');
const p2 = new Person('花子', 23, '女');

```

## インスタンス間で共有されるメソッド（全てのクラスで同じ関数など）
- class で定義したメソッドは、JavaScript エンジンによって prototype に配置され、全インスタンスで共有される

```js
class User {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  // 全員で共有
  greeting() {
    console.log(`Hi, I'm ${this.name}`);
  }
}
```
- 同じ関数を 毎回作るのは無駄
- prototype に置けば 1つを全員で共有
- JavaScript は prototype チェーンでメソッド探索する
- constructor 関数の prototype は new されたオブジェクトの親

## インスタンスを生成する方法（2種類）
- Factory関数（this を使わず、関数がオブジェクトを直接返す）
```js
function createUser(name, age) {
  return { name, age };
}
```
- new（ほぼこっちが使われる）

## thisが指すもの
- newで生成されたインスタンス（もの）自体をthisは指す
- だから何個も似たようなオブジェクト（クラス）を作っても、thisはそれぞれ生成されたインスタンスを指してる

## constructor
- constructor = 初期値を設定する
- new した瞬間に1回だけ呼ばれる

## カプセル化
- 中身の実装や状態を隠し、使っていい操作だけを外に公開すること
- **触っていいところだけ public**（アクセス修飾子）
- **それ以外は private**（アクセス修飾子）
- オブジェクト自身が変更可能＝**ミュータブル**という
- 一度作ったら中身を変更できない＝**イミュータブル**という

## メンバー変数
```js
private name: string;
private age: number;
private gender: string;
```
上記の指定を、**メンバー変数**と呼ぶ


## オブジェクト指向
- 「状態（データ）と振る舞い（処理）を、1つの"もの（オブジェクト）"にまとめて扱う考え方」

## インスタンス
- クラスから作られたオブジェクト（モノ）
- new を使って生成したモノを「インスタンス」という

## まとめると
- クラスは設計図
- new でインスタンス（もの）を作る
- this はそのインスタンス自身を指す
- 同じクラスから複数の独立したインスタンスを作れる
- それぞれが自分の状態を持つ
＝オブジェクト指向


| 概念     | 実体           |
| ------ | ------------ |
| クラス    | 設計図          |
| new    | 製造           |
| インスタンス | 作られた物        |
| this   | 「今使われているその物」 |

## getter / setter
- getter：プロパティを「読むとき」に動く関数
- setter：プロパティに「代入するとき」に動く関数（使いどころ注意・ほぼ使わない）

```js
class User {
  constructor(name, age) {
    this._name = name;
    this._age = age;
  }

  get age() {
    return this._age;
  }

  set age(value) {
    if (value < 0) {
      throw new Error("年齢は0以上");
    }
    this._age = value;
  }
}
```
＝getやsetを関数の前につけるだけでOK

```js
// 使い方
const user = new User("Taro", 20);

user.age;      // 20（getter）
user.age = 25; // setter
```

### 使っていい順
①✅ getter（計算のみ）
②⚠️ setter（軽い代入だけ）
③❌ setterでロジック

### 判断基準
「それは**値**か？ **操作**か？」
- 値 → getter
- 操作 → メソッド

## Object.hasOwn
＝オブジェクトがそのプロパティを**自分自身として**持っているかどうかを調べるメソッド

```js
// オブジェクトの 自前のプロパティ を持っているかどうかを判定
Object.hasOwn(obj, "key"); // objは、keyというプロパティを持ってるか
```
- true → そのオブジェクト自身が持っているプロパティ
- false → 持っていない（または prototype 由来）

### 例
```js
const obj = { name: "Taro" };

Object.hasOwn(obj, "name"); // true
Object.hasOwn(obj, "toString"); // false（prototype のものだから）
```
⚠️ in演算子と似ているか、in演算子はプロトタイプ（親）まで見に行く
⚠️ Object.hasOwnは、自身のみ見る
⚠️ プロトタイプにおけるものは基本関数（動き）のみ

## new.target
＝newで呼ばれているか判定するメソッド
＝呼ばれてる場合 → 値で返される
＝呼ばれていない場合 → undefindで返される

| 種類 | 役割 | いつ実行される | 書き方の例 |
|------|------|----------------|------------|
| **constructor** | インスタンスの初期化（最初に一度だけ） | `new` した瞬間 | `constructor() { ... }` |
| **インスタンスメソッド**（例：add, speak） | インスタンスに対する操作 | 必要なときに何度でも | `add(name) { ... }` |
| **getter** | 値を取得するための専用メソッド | プロパティのように呼ばれる | `get count() { ... }` |
| **setter** | 値を設定するための専用メソッド | プロパティのように代入される | `set name(v) { ... }` |
| **static メソッド** | インスタンスではなくクラス自体に属する処理 | クラス名から呼ぶ | `static create() { ... }` |
| **static プロパティ** | クラスに属する値（インスタンスごとではない） | クラス名から参照 | `static version = 1` |
| **private メソッド** | クラス内部だけで使う補助処理 | 内部からのみ | `#validate() { ... }` |
