# 非破壊的

## slice
＝引数で指定した部分のみ切り取る
＝元の配列には影響しない

```js
// 定型文
array.slice(開始位置, 終了位置);

// 例
const arr = [1, 2, 3, 4];
const newArr = arr.slice(1, 3);

console.log(arr);    // [1, 2, 3, 4] ← 変わらない
console.log(newArr); // [2, 3]
```
- slice → 非破壊（元の配列は変わらない）
- splice → 破壊（元の配列を変更する）
- 書き方は array.slice(start, end)

## concat
＝配列をくっつける
＝元の配列には影響しない

```js
// 定型文
array.concat(追加する値1, 追加する値2, ...);

// 配列を結合
const a = [1, 2];
const b = [3, 4];

const result = a.concat(b);

console.log(result); // [1, 2, 3, 4]
console.log(a);      // [1, 2] ← 変わらない

// 値を追加
[1, 2].concat(3, 4);
// → [1, 2, 3, 4]
```
- concat → 非破壊的（元の配列は変わらない）
- 定型文：array.concat(値 or 配列...)
- 複数の値や配列をまとめてくっつけられる

## join
＝配列を**文字列**に変換するメソッド
＝元の配列を崩さない

```js
// 定型文
array.join(区切り文字); // デフォルトは ","

// 例
[1, 2, 3].join();
// → "1,2,3"

[1, 2, 3].join("-");
// → "1-2-3"

["a", "b", "c"].join("");
// → "abc"
```
- join → 配列を文字列に変換する（非破壊）
- 定型文：array.join(区切り文字)
- 区切り文字は省略可（デフォルトはカンマ）

## indexOf
＝最初に見つかったindex番号を返す
＝元の配列を崩さない

```js
// 定型文
array.indexOf(探す値, 開始位置);

// 例
[1, 2, 3, 2].indexOf(2);
// → 1
```
-見つかったら インデックス番号
見つからなければ -1 を返す


## lastIndexOf
＝最後に見つかったindex番号を返す
＝元の配列を崩さない

```js
array.lastIndexOf(探す値, 開始位置);

// 例
[1, 2, 3, 2].lastIndexOf(2);
// → 3
```
- 見つかったら 最後に出てきた位置のインデックス
- 見つからなければ -1 を返す

## includes
＝引数に指定した値が含まれてるかどうか
＝元の配列を崩さない

```js
// 定型文
array.includes(探す値, 開始位置);

// 例
[1, 2, 3].includes(2);
// → true
```
- 見つかったら true
- 見つからなければ false

## flat
＝ネストした配列を平坦化する

```js
// 定型文
array.flat(深さ); // 深さ：どこまで平坦化するか（デフォルトは 1）

// 例
const arr = [1, [2, 3]]; // []の中に[]があるが、それを平坦にする
const result = arr.flat();

console.log(arr);    // [1, [2, 3]] ← 元の配列はそのまま
console.log(result); // [1, 2, 3]

// 引数あり
const arr = [1, [2, 3], [4, [5]]]; // []がつくものが深さ1、さらに[]がつくものは深さ2
const result = arr.flat(1); // 引数は1なので、最初の[]しか見てない

console.log(result);
// → [1, 2, 3, 4, [5]]


[1, [2, 3], [4, [5]]]
 ↓ 1段目
[1, 2, 3, 4, [5]]
 ↓ 2段目
[1, 2, 3, 4, 5]
```

## flatMap
＝map → flat(1) をまとめてやるメソッド

```js
// 定型文
array.flatMap(コールバック関数); // コールバック関数：各要素をどう変換するか（結果は 1段だけ平坦化される）

// 例
const arr = [1, 2, 3];
const result = arr.flatMap(n => [n, n * 2]);

console.log(arr);    // [1, 2, 3] ← 元の配列はそのまま
console.log(result); // [1, 2, 4, 3, 6]

// 引数あり
const arr = [10, 20, 30];
const result = arr.flatMap((value, index, array) => {
  return [
    value,          // 現在の値
    index,          // インデックス
    array.length    // 配列全体の長さ
  ];
});

console.log(arr);
// → [10, 20, 30]  ← 元の配列はそのまま

console.log(result);
// → [10, 0, 3, 20, 1, 3, 30, 2, 3]


[
  [10, 0, 3],
  [20, 1, 3],
  [30, 2, 3]
]

// flat(1) で 1段平坦
[10, 0, 3, 20, 1, 3, 30, 2, 3]
```

## reduce
```js
// 定型文
array.reduce((accumulator, value, index, array) => 処理, 初期値);
```

| 引数 | 意味 |
|------|------|
| accumulator（累積値） | 前回の戻り値が入る |
| value（現在の値） | 今処理している要素 |
| index | 現在のインデックス |
| array | 元の配列 |
| 初期値 | accumulator の初期値になる値 |

## reduceRight
＝reduceの逆
＝reduce → 左から右へ処理
＝reduceRight → 右から左へ処理

```js
// 定型文
array.reduceRight((accumulator, value, index, array) => 処理, 初期値);
```
- 右端の要素から順番にコールバックを実行する
- 最終的に 1つの値 を作る
- reduce と同じだけど 方向が逆

### reduce と reduceRight の違い
```js
const arr = ["a", "b", "c"];

const r1 = arr.reduce((acc, v) => acc + v);
console.log(r1);
// "abc"   ← 左から右へ

const r2 = arr.reduceRight((acc, v) => acc + v);
console.log(r2);
// "cba"   ← 右から左へ
```

## find
＝条件に合う最初の要素を返す

```js
// 定型文
array.find((value, index, array) => 条件); // mapとかと同じ

// 例
const arr = [10, 20, 30, 40];

const result = arr.find(num => num > 25); // 最初に見つけた要素のみなので、30だけ

console.log(result); // 30
console.log(arr);    // [10, 20, 30, 40] ← 非破壊
```

## findIndex
＝条件に合う最初の要素のインデックスを返す

```js
// 定型文
array.findIndex((value, index, array) => 条件);

// 例
const arr = [10, 20, 30, 40];

const result = arr.findIndex(v => v > 25); // 最初につけた要素のindex番号なので2

console.log(result); // 2
console.log(arr);    // [10, 20, 30, 40]
```

## findLast
＝条件に合う“最後の”要素を返す
＝findの逆

```js
// 定型文
array.findLast((value, index, array) => 条件); // 最後に見つけた値を返すので40

// 例
const arr = [10, 20, 30, 40];

const result = arr.findLast(v => v > 15);

console.log(result); // 40（最後に条件を満たす要素）
console.log(arr);    // [10, 20, 30, 40]
```

## findLastIndex
＝条件に合う“最後の”要素のインデックスを返す
＝findIndexの逆

```js
// 定型文
array.findLastIndex((value, index, array) => 条件);

// 例
const arr = [10, 20, 30, 40];

const result = arr.findLastIndex(v => v > 15); // 最後に見つけたindex番号なので3

console.log(result); // 3
console.log(arr);    // [10, 20, 30, 40]
```


## some
＝1つでも条件を満たせば true
＝true or false で返す

```js
// 定型文
array.some((value, index, array) => 条件);

// 例
const arr = [1, 3, 5];
const result = arr.some(num => num % 2 === 0);

console.log(result); // false（偶数が1つもない）
console.log(arr);    // [1, 3, 5] ← 非破壊
```

## every
＝すべてが条件を満たせば true
＝true or false で返す

```js
// 定型文
array.every((value, index, array) => 条件);

// 例
const arr = [2, 4, 6];

const result = arr.every(v => v % 2 === 0);

console.log(result); // true（全部偶数）
console.log(arr);    // [2, 4, 6] ← 非破壊
```

## forEach
＝配列の全要素に対して処理を実行

```js
// 定型文
array.forEach((value, index, array) => 処理);

// 例
const arr = [10, 20, 30];

arr.forEach((num, index) => { // numは各要素、indexは各要素のindex番号
  console.log(index, num);
});

// 出力:
// 0 10
// 1 20
// 2 30

console.log(arr); // [10, 20, 30] ← 非破壊
```

## at
＝配列の要素を「正のインデックス」「負のインデックス」で取得できるメソッド
＝メリットは負のインデックスが使えること

```js
// 定型文
array.at(位置);

// 負の数の例
const arr = [10, 20, 30, 40]; // 負の数は右から数える

arr.at(-1); // 40（最後の要素）
arr.at(-2); // 30（後ろから2番目）

// 普通の関数
const arr = [10, 20, 30]; // 正の数は、左から数える

arr.at(0); // 10
arr.at(1); // 20
```

- 正の数（0, 1, 2…） → **左から数える**
- 負の数（-1, -2, -3…） → **右から数える**


## with
＝配列の特定の位置の値を “非破壊で” 置き換える

つまり:
- `arr[index] = value` の 非破壊版
- 元の配列は変わらない

```js
// 定型文
array.with(位置, 新しい値);

// 例
const arr = [10, 20, 30];
const result = arr.with(1, 999); // 1番目の要素を999に置き換える

console.log(arr);    // [10, 20, 30] ← 元の配列はそのまま
console.log(result); // [10, 999, 30]
```

## Object.groupBy()
＝配列をグループ分けする
＝配列の要素を 任意のルールでグループ化してオブジェクトにまとめる

```js
// 定型文
Object.groupBy(array, (value, index, array) => グループ名);

// 例：偶数・奇数でグループ分け
const arr = [1, 2, 3, 4, 5];

const result = Object.groupBy(arr, v => v % 2 === 0 ? "even" : "odd");

console.log(result);
// {
//   odd: [1, 3, 5],
//   even: [2, 4]
// }

// オブジェクト配列を年齢でグループ化
const users = [
  { name: "A", age: 20 },
  { name: "B", age: 30 },
  { name: "C", age: 20 }
];

const grouped = Object.groupBy(users, u => u.age);

console.log(grouped);
// {
//   20: [{name:"A", age:20}, {name:"C", age:20}],
//   30: [{name:"B", age:30}]
// }
```