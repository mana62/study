# イベント・非同期 （キュー）
- **非同期とは**
  - 重い処理を「裏で」実行して、ユーザーを待たせないようにする仕組み
- **イベント （Event）とは**
  - ある出来事（Event）が起きたときに、何かの処理（Listener）を発火させる仕組み
- **キュー（Queue）とは**
  - 「重い処理をすぐに実行せず、一時的に"待機列"に入れてあとで裏で処理する仕組み」

<br>

**登場人物はこの3人**
  - 発火する人（誰かがイベントを起こす）
  - イベント（出来事を運ぶ人）
  - リスナー（出来事を受けて動く人）

| 役割   | クラス                | 何をする              |
| ---- | ------------------ | ----------------- |
| 起こす  | Controller / Model | event(...) を呼ぶ    |
| 運ぶ   | Event              | 必要なデータ（Userなど）を持つ |
| 反応する | Listener           | handle() 内で処理を行う  |
| 遅らせる | ShouldQueue        | 処理を後で実行させる        |



| 概念           | 内容                | メリット            |
| ------------ | ----------------- | --------------- |
| **イベント**     | 「〇〇が起きた」と伝える仕組み   | コードの責務を分けてスッキリ  |
| **リスナー**     | イベントが起きた時に実行される処理 | 再利用しやすくなる       |
| **非同期（キュー）** | 時間がかかる処理を裏で実行     | レスポンスが速くなる／負荷分散 |


- **ジョブ**：単一の処理（メール送信や外部API呼び出しなど）を非同期でやる
- **イベント＋リスナー**：複数の処理を同時にトリガーしたい時に便利

---

## イベントの定型分
```php
// イベント（例）
class OrderCreated {
    public Order $order;

    public function __construct(Order $order) {
        $this->order = $order;
    }
}
```
- public プロパティ（Order $order）
- constructor（__construct） をセットで書くのが一般的
- イベント / ジョブ / リスナーは必ず同じような constructor を書く
- ジョブを使いたい時は dispatch を使う

```php
// リスナー
public function handle(OrderCreated $event)
{
    // $event->order にアクセスできる
}
```

```php
// キュー（非同期）発火
CheckStockJob::dispatch($productId);
```
- コントローラで呼んでもOK
- サービスクラスで呼んでもOK
- リスナーで呼んでもOK
- イベントの中で呼んでもOK
- 基本的にどこでも dispatch できる


- ジョブの{}について
```php
public function __construct(
    public int $productId
) {}
```
- 特別な意味はない
- 中身が空だから {} が空だから

---

## 流れ
- たとえば「ユーザーが登録されたらメールを送る」という処理

#### 🟢 通常
```php
public function store(Request $request)
{
    $user = User::create($request->all());
    Mail::to($user->email)->send(new WelcomeMail($user)); // メール送信
}
```
**問題点**
- 「ユーザー登録」と「メール送信」が同じ場所に書かれていて ごちゃごちゃ してる
- メール送信に時間がかかると、画面のレスポンスも遅くなる

#### 🟢 改善 「イベント」を使う
① ユーザー登録時に「UserRegistered」イベントを発火 <br>
② そのイベントを「SendWelcomeMail」リスナーが受け取って実行 <br>

**流れ・やり方**
#### ① イベントを作成
```bash
php artisan make:event UserRegistered
```
```php
// app/Events/UserRegistered.php
class UserRegistered
{
    public $user;
    // __construct : コンストラクタと呼ばれる特別なメソッドで、 クラスのインスタンスが作られたときに自動で呼び出される
    public function __construct($user)
    {
        $this->user = $user;
    }
}
```
- __constructについて
  - __construct : コンストラクタと呼ばれる特別なメソッドで、 クラスのインスタンスが作られたときに自動で呼び出される
      - プロパティの初期化
      - 依存関係の注入（DI）
      - インスタンス生成時の準備処理

#### ② リスナーを作成
```bash
php artisan make:listener SendWelcomeMail --event=UserRegistered
```
```php
// app/Listeners/SendWelcomeMail.php
class SendWelcomeMail
{
    public function handle(UserRegistered $event)
    {
        Mail::to($event->user->email)->send(new WelcomeMail($event->user));
    }
}
```

#### ③ イベントとリスナーの接続
**EventServiceProvider に登録**

```bash
protected $listen = [
    UserRegistered::class => [
        SendWelcomeMail::class,
        SlackNotice::class,
        LogNotice::class,
    ],
];

# UserRegistered::class : イベントクラス（ユーザー登録されたときに発火）
# SendWelcomeMail::class など → リスナー（イベントが発生したら実行される処理）

```



#### ④ イベント発火
```bash
# コントローラなどで
event(new UserRegistered($user));
```
→ これで、登録後に自動でリスナーが呼ばれてメールを送ってくれる

#### ⑤ 非同期処理にする方法（Queue対応）
- リスナーに「ShouldQueue」インターフェイスを付けるだけ

```php
use Illuminate\Contracts\Queue\ShouldQueue;

class SendWelcomeMail implements ShouldQueue
{
    public function handle(UserRegistered $event)
    {
        Mail::to($event->user->email)->send(new WelcomeMail($event->user));
    }
}
```
- これで、このリスナーはキューに積まれて「裏で」実行される✨
  - ユーザーはすぐに登録完了画面を見る
  - メール送信は裏で行われる

#### ⑥ 実際にキューを動かす
- キューに積まれた処理は ワーカー（worker） が裏で実行

```bash
php artisan queue:work
```
- これで裏側でジョブが次々と処理されていく

#### ⑦ キューの保存場所
- キューの「待機列」をどこに保存するかは .env で指定する

```bash
QUEUE_CONNECTION=database
```

**※ データベースを使う場合は、テーブルを作る必要がある**
```bash
php artisan queue:table
php artisan migrate
```
→ これで jobs テーブルにキューが貯まるようになる

<br>
<br>
<br>
<br>


| 概念            | 役割               | ポイント                        |
| ------------- | ---------------- | --------------------------- |
| **イベント**      | 何か起きたことを通知する     | 「UserRegistered」など          |
| **リスナー**      | イベントに反応して処理する    | 「SendWelcomeMail」など         |
| **キュー**       | 時間のかかる処理を後で実行    | レスポンスを高速化                   |
| **Mailables** | メールの内容とテンプレートを定義 | `php artisan make:mail` で作る |
| **キュー＋メール**   | 非同期メール送信         | `.queue()` or `ShouldQueue` |



---

## Laravelのキュー関連用語

| 用語     | 説明                                                                 |
|----------|----------------------------------------------------------------------|
| キュー   | 決まった処理を非同期で実行するための仕組み。ジョブを順番に処理する     |
| ジョブ   | 実行する処理そのもの。キューに登録されて、後でワーカーにより実行される |
| ワーカー | ジョブを処理するプロセス。キューからジョブを取り出して実行する役割       |



---

## イベント＆非同期（キュー）を使用する場面

| カテゴリ                          | 処理内容                     | なぜ非同期にするか？          |
| ----------------------------- | ------------------------ | ------------------- |
| **メール送信**                  | 会員登録、パスワードリセット、注文完了など    | メール送信はSMTP通信が遅いため   |
| **ログ記録／監査**                | 「誰がどの操作をしたか」をDBや外部ログに記録  | 毎回DBにINSERTすると遅い    |
| **画像処理**                  | サムネイル生成、画像リサイズ、透かし追加など   | 画像処理はCPU負荷が高い       |
| **AI・外部API呼び出し**           | ChatGPTや画像認識APIに送信する     | 応答に時間がかかる（数秒〜数十秒）   |
| **大量データ処理**                | CSVインポート、レポート出力、集計バッチなど  | 数千〜数万件を処理するため時間が長い  |
| **通知送信（Notification）**     | Slack通知、LINE通知、SMS送信など   | 外部サービスへの通信が遅い       |
| **決済後の処理**                 | 購入完了後の在庫更新、領収書PDF生成など    | 同期でやるとユーザー待ち時間が長い   |
| **定期ジョブ**               | 毎晩データ集計、古いログ削除など         | スケジュール（cron）でキューに積む |
| **Webhook受信処理**            | Stripe・PayPalなど外部からの通知処理 | 外部リクエストを即レスし、裏で実処理  |
| **リアルタイム通知（Broadcasting）** | チャット、コメント通知、いいね通知        | イベントで通知をリアルタイム配信    |

---

## イベントを発火させる場所

| ケース                                     | イベントを発火させる場所                         | 理由                               |
| --------------------------------------- | ------------------------------------ | -------------------------------- |
| **モデルに直接関係する処理（作成・更新・削除）**              | ✅ **モデル**（`booted()` や Eloquentイベント） | 「データが作成されたら〜する」というのはモデルの責務だから    |
| **フォーム送信やAPIリクエストなど、アプリ操作の結果として発生する処理** | ✅ **コントローラ or サービスクラス**              | ユーザー操作（アプリ層）に対応するから              |
| **特定のビジネス処理（例：注文確定、会員登録完了など）**          | ✅ **サービスクラス**がベスト                    | モデルの保存やAPI呼び出しなど、複数の処理をまとめる場所だから |




#### ① モデルで発火（Eloquentイベント利用）
- モデルが自分のデータ変化をトリガーに「内部的なイベント」を出す場合

```php
// app/Models/Order.php
protected static function booted()
{
    static::created(function ($order) {
        event(new OrderPlaced($order)); // モデル生成後、自動で発火
    });
}
```

**使うイベント**
  - creating / created
  - updating / updated
  - deleting / deleted など（Eloquentが自動で呼ぶ）


#### ② コントローラで発火（操作の結果）
- 画面操作やAPI呼び出しなど、「ユーザー行動が原因」で発火する場合

```php
// app/Http/Controllers/OrderController.php
public function store(Request $request)
{
    $order = Order::create($request->all());

    // ここでイベントを発火
    event(new OrderPlaced($order));

    return response()->json(['message' => '注文を受け付けました']);
}
```

**メリット**
- モデルを汚さず、アプリの操作ごとに明確に発火できる
- 特定のアクションでのみ動かしたいときに便利

#### ③ サービスクラスで発火（ビジネス処理中）
- 「注文確定」や「ユーザー登録完了」などの 業務的なイベント に最適

```php
// app/Services/OrderService.php
public function placeOrder(array $data)
{
    $order = Order::create($data);

    // 他の処理（在庫減少、履歴追加など）
    // ...

    // ビジネスイベント発火
    event(new OrderPlaced($order));
}
```

**一番実務的でおすすめ**
- コントローラは「入力と出力」だけに集中できる
- モデルのEloquentイベントよりも柔軟（DB以外の処理も対象にできる）

**まとめ**
| 目的                | 場所     | 発火方法                             |
| ----------------- | ------ | -------------------------------- |
| モデルのCRUDに応じて自動実行  | モデル    | `booted()` + `static::created()` |
| リクエスト後の処理として      | コントローラ | `event(new イベント名($data))`        |
| 業務処理（まとめたロジック）として | サービス   | `event(new イベント名($data))`        |


- 現場では「モデル発火」は最小限で、多くは「サービスクラス or コントローラ」で発火
- モデルは「データ保存と整形」まで
- イベント発火やメール送信は「サービス」に任せる
- サービスは「1ユースケースをまとめる」単位（＝アプリの動作単位）

---

| 種類                                                  | 書く場所         | 役割                        | いつ実行されるか                                 |
| --------------------------------------------------- | ------------ | ------------------------- | ---------------------------------------- |
| `event(new UserRegistered($user));`                 | モデル・コントローラなど | イベントを「発火」する（＝起こす）         | 実行時（コードが走った瞬間）                           |
| `public function __construct(public User $user) {}` | イベントクラス内     | イベントが「発火されたときに渡されるデータ」を定義 | イベント生成時（`new UserRegistered($user)` の瞬間） |


---

## Laravel 非同期処理／イベント用の組み込みメソッド・プロパティ一覧

| 名前                                              | 種類       | 説明                          | 使う場所                |
| ----------------------------------------------- | -------- | --------------------------- | ------------------- |
| **ShouldQueue**                                 | インターフェイス | リスナー・ジョブをキュー（非同期）で実行する契約    | リスナー／ジョブクラス         |
| **InteractsWithQueue**                          | Trait    | キューの操作を簡単に行える（削除、再試行など）     | リスナー／ジョブクラス         |
| **Queueable**                                   | Trait    | キュー設定（接続、キュー名、遅延時間など）を簡単に設定 | リスナー／ジョブクラス         |
| **SerializesModels**                            | Trait    | モデルをシリアライズしてキューに渡す          | リスナー／ジョブクラス         |
| **$tries**                                      | プロパティ    | 失敗時の再試行回数                   | リスナー／ジョブクラス         |
| **$timeout**                                    | プロパティ    | ジョブの最大実行時間（秒）               | リスナー／ジョブクラス         |
| **$backoff**                                    | プロパティ    | 再試行間隔（秒）                    | リスナー／ジョブクラス         |
| **failed(Exception $exception)**                | メソッド     | 最大再試行回数まで失敗したときの処理          | リスナー／ジョブクラス         |
| **delay() / onQueue() / onConnection()**        | メソッド     | ジョブやリスナーの遅延実行・キュー名・接続を指定    | ジョブ／dispatch() 時に使用 |
| **dispatch() / dispatchSync() / dispatchNow()** | メソッド     | ジョブ・イベントをキューに登録・同期実行        | ジョブ／イベント            |


**ポイント**
- ShouldQueue がないと $tries や failed() は無効
- InteractsWithQueue / Queueable / SerializesModels は便利機能
  - SerializesModels → モデルを安全にキューに渡せる
  - Queueable → queue名や接続、遅延時間を設定可能
- イベントでも非同期化する場合はリスナーに ShouldQueue を付ける

<br>
<br>

- 契約系：ShouldQueue（やるかどうか）
- 処理系：failed(), $tries, $timeout
- 設定系：Queueable, delay(), onQueue()
- データ渡し系：SerializesModels

---

## 参考
- [Laravelでの非同期処理についてまとめてみた](https://tech-blog.rakus.co.jp/entry/20230125/laravel)

---

| 場所                       | 書くもの                        | 役割                  |
| ------------------------ | --------------------------- | ------------------- |
| **Event**                | `__construct(Model $model)` | リスナーへ渡すための「データ入れ物」  |
| **Listener**             | `handle(Event $event)`      | イベントからデータを取り出して処理する |
| **$event->order->items** | リレーション                      | モデルの関連データへアクセス      |
